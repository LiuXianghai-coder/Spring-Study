然而这样做会产生重复计数。如果 $s[j_0]$ 和 $s[j_1]$ 这两个字符不相同，那么 $f[j_0]$ 和 $f[j_1]$ 对应的子序列是两个不相交的集合；但如果 $s[j_0]$ 和 $s[j_1]$ 这两个字符相同，那么 $f[j_0]$ 和 $f[j_1]$ 对应的子序列会包含重复的项。最简单的一个重复项就是只含有一个字符的子序列 $s[j_0]$ 或者 $s[j_1]$ 本身。

那么我们该如何防止重复计数呢？可以发现，如果 $j_0<j_1$，那么 $f[j_0]$ 一定是 $f[j_1]$ 的一个真子集。这是因为：

> 每一个以 $s[j_0]$ 为最后一个字符的子序列，都可以把这个字符改成完全相同的 $s[j_1]$，计入到 $f[j_1]$ 中。

因此，对于每一种字符，我们只需要找到其最后一次出现的位置（并且在位置 $i$ 之前），并将对应的 $f$ 值累加进 $f[i]$ 即可。由于本题中字符串只包含小写字母，我们可以用 $\textit{last}[k]$ 记录第 $k~(0 \leq k < 26)$ 个小写字母最后一次出现的位置。如果它还没有出现过，那么 $\textit{last}[k] = -1$。这样我们就可以写出正确的状态转移方程：
